package com.unifiedwebrtc

import android.content.Context
import android.os.Handler
import android.os.Looper
import android.util.Log
import android.widget.FrameLayout
import com.facebook.react.bridge.Arguments
import com.facebook.react.bridge.WritableMap
import com.facebook.react.uimanager.ThemedReactContext
import com.facebook.react.uimanager.events.RCTEventEmitter
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.Response
import okhttp3.WebSocket
import okhttp3.WebSocketListener
import org.webrtc.*
import java.io.BufferedReader
import java.io.InputStreamReader
import java.io.OutputStreamWriter
import java.net.HttpURLConnection
import java.net.URL
import java.util.concurrent.CountDownLatch
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit
import org.json.JSONObject
import java.net.URI

class UnifiedWebrtcView(context: Context) : FrameLayout(context) {

    private val TAG = "UnifiedWebrtcView"
    private val eglBaseContext: EglBase.Context = EglBase.create().eglBaseContext
    private var peerConnectionFactory: PeerConnectionFactory? = null
    private var localVideoTrack: VideoTrack? = null
    private var remoteVideoTrack: VideoTrack? = null
    private var surfaceViewRenderer: SurfaceViewRenderer? = null
    private var peerConnection: PeerConnection? = null
    private var reactContext: ThemedReactContext? = null
    private val executor = Executors.newSingleThreadExecutor()
    private var iceGatheringComplete = false
    private var whepOfferSent = false
    private var pendingStreamUrl: String? = null
    private var localOffer: SessionDescription? = null
    private var lastEmittedConnectionState: String? = null
    private val connectionStateLock = Any()
    private val addedVideoTracks = mutableSetOf<String>()
    private val videoTrackLock = Any()
    private var iceGatheringTimeoutHandler: Handler? = null
    private var iceGatheringTimeoutRunnable: Runnable? = null

    init {
        if (context is ThemedReactContext) {
            reactContext = context
            initializeWebRTC(context)
        }
    }

    private fun initializeWebRTC(reactContext: ThemedReactContext) {
        Log.d(TAG, "Initializing WebRTC")
        
        // Initialize PeerConnectionFactory with H.265 support and software decoding
        val initializationOptions = PeerConnectionFactory.InitializationOptions.builder(reactContext.applicationContext)
            .setFieldTrials(
                "WebRTC-H264HighProfile/Enabled/" +
                "WebRTC-H265Codec/Disabled/" +
                "WebRTC-DisableHardwareVideoDecoding/Disabled/" +
                "WebRTC-SoftwareVideoDecoderFallback/Enabled/"
            )
            .createInitializationOptions()
        PeerConnectionFactory.initialize(initializationOptions)

        // Create video decoder/encoder factories with H.265 support and fallback
        val videoDecoderFactory = createVideoDecoderFactory()
        val videoEncoderFactory = DefaultVideoEncoderFactory(eglBaseContext, true, true)

        val factoryBuilder = PeerConnectionFactory.builder()
            .setVideoDecoderFactory(videoDecoderFactory)
            .setVideoEncoderFactory(videoEncoderFactory)
            .setOptions(PeerConnectionFactory.Options())

        peerConnectionFactory = factoryBuilder.createPeerConnectionFactory()

        // Create SurfaceViewRenderer for video
        surfaceViewRenderer = SurfaceViewRenderer(context)
        surfaceViewRenderer?.init(eglBaseContext, null)
        surfaceViewRenderer?.setMirror(false)
        surfaceViewRenderer?.setEnableHardwareScaler(true)
        surfaceViewRenderer?.setScalingType(RendererCommon.ScalingType.SCALE_ASPECT_FIT)
        
        val layoutParams = LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT)
        addView(surfaceViewRenderer, layoutParams)
        
        Log.d(TAG, "WebRTC initialization complete")
    }

    private fun createVideoDecoderFactory(): VideoDecoderFactory {
        return try {
            Log.d(TAG, "Creating filtered video decoder factory (excluding H.265)")
            // Create a factory that excludes H.265 to prevent crashes
            val hardwareFactory = DefaultVideoDecoderFactory(eglBaseContext)
            val softwareFactory = SoftwareVideoDecoderFactory()
            
            // Filter out H.265 codec to prevent server from sending unsupported streams
            object : VideoDecoderFactory {
                override fun createDecoder(codecInfo: VideoCodecInfo): VideoDecoder? {
                    Log.d(TAG, "Creating decoder for codec: ${codecInfo.name}")
                    return try {
                        // Try software decoder first, then hardware
                        softwareFactory.createDecoder(codecInfo) ?: hardwareFactory.createDecoder(codecInfo)
                    } catch (e: Exception) {
                        Log.w(TAG, "Failed to create decoder for ${codecInfo.name}: ${e.message}")
                        null
                    }
                }
                
                override fun getSupportedCodecs(): Array<VideoCodecInfo> {
                    // Get all supported codecs but filter out H.265/HEVC
                    val hardwareCodecs = hardwareFactory.supportedCodecs
                    val softwareCodecs = softwareFactory.supportedCodecs
                    
                    // Combine and filter codecs
                    val allCodecs = (hardwareCodecs + softwareCodecs).distinctBy { it.name }
                    val filteredCodecs = allCodecs.filter { codec ->
                        val codecName = codec.name.uppercase()
                        val isH265 = codecName == "H265" || codecName == "HEVC"
                        if (isH265) {
                            Log.d(TAG, "Filtering out H.265/HEVC codec to prevent crashes")
                        }
                        !isH265
                    }.toTypedArray()
                    
                    Log.d(TAG, "Supported codecs: ${filteredCodecs.map { it.name }}")
                    return filteredCodecs
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Failed to create filtered video decoder factory", e)
            // Fallback to software-only decoder
            SoftwareVideoDecoderFactory()
        }
    }

    private fun getIceServers(): List<PeerConnection.IceServer> {
        return listOf(
            PeerConnection.IceServer.builder("stun:stun.l.google.com:19302").createIceServer(),
            PeerConnection.IceServer.builder("stun:stun1.l.google.com:19302").createIceServer(),
            PeerConnection.IceServer.builder("stun:stun2.l.google.com:19302").createIceServer()
        )
    }

    private fun sendEventToReactNative(eventName: String, params: WritableMap) {
        reactContext?.getJSModule(RCTEventEmitter::class.java)?.receiveEvent(
            id,
            eventName,
            params
        )
    }

    fun createOffer() {
        Log.d(TAG, "Creating WebRTC offer")
        
        if (peerConnection == null) {
            setupPeerConnection()
        }

        val constraints = MediaConstraints().apply {
            mandatory.add(MediaConstraints.KeyValuePair("OfferToReceiveVideo", "true"))
            mandatory.add(MediaConstraints.KeyValuePair("OfferToReceiveAudio", "false"))
        }

        peerConnection?.createOffer(object : SdpObserver {
            override fun onCreateSuccess(sdp: SessionDescription?) {
                Log.d(TAG, "Offer created successfully")
                sdp?.let {
                    peerConnection?.setLocalDescription(this, it)
                    
                    // Send SDP to React Native
                    val params = Arguments.createMap().apply {
                        putString("type", it.type.canonicalForm())
                        putString("sdp", it.description)
                    }
                    sendEventToReactNative("onLocalSdpReady", params)
                }
            }

            override fun onCreateFailure(error: String?) {
                Log.e(TAG, "Failed to create offer: $error")
            }

            override fun onSetSuccess() {}
            override fun onSetFailure(error: String?) {}
        }, constraints)
    }

    fun createAnswer() {
        Log.d(TAG, "Creating WebRTC answer")
        
        val constraints = MediaConstraints().apply {
            mandatory.add(MediaConstraints.KeyValuePair("OfferToReceiveVideo", "true"))
            mandatory.add(MediaConstraints.KeyValuePair("OfferToReceiveAudio", "true"))
        }

        peerConnection?.createAnswer(object : SdpObserver {
            override fun onCreateSuccess(sdp: SessionDescription?) {
                Log.d(TAG, "Answer created successfully")
                sdp?.let {
                    peerConnection?.setLocalDescription(this, it)
                    
                    // Send SDP to React Native
                    val params = Arguments.createMap().apply {
                        putString("type", it.type.canonicalForm())
                        putString("sdp", it.description)
                    }
                    sendEventToReactNative("onLocalSdpReady", params)
                }
            }

            override fun onCreateFailure(error: String?) {
                Log.e(TAG, "Failed to create answer: $error")
            }

            override fun onSetSuccess() {}
            override fun onSetFailure(error: String?) {}
        }, constraints)
    }

    fun setRemoteDescription(sdp: SessionDescription) {
        Log.d(TAG, "Setting remote description: ${sdp.type}")
        peerConnection?.setRemoteDescription(object : SdpObserver {
            override fun onSetSuccess() {
                Log.d(TAG, "Remote description set successfully")
            }

            override fun onSetFailure(error: String?) {
                Log.e(TAG, "Failed to set remote description: $error")
            }

            override fun onCreateSuccess(p0: SessionDescription?) {}
            override fun onCreateFailure(p0: String?) {}
        }, sdp)
    }

    fun addIceCandidate(candidate: IceCandidate) {
        Log.d(TAG, "Adding ICE candidate: ${candidate.sdpMid}")
        peerConnection?.addIceCandidate(candidate)
    }

    fun playStream(streamUrlOrSignalingInfo: String) {
        Log.d(TAG, "Starting stream playback: $streamUrlOrSignalingInfo")
        
        executor.execute {
            try {
                if (peerConnection == null) {
                    setupPeerConnection()
                }
                
                // For WebRTC streaming URLs, we need to:
                // 1. Create an offer
                // 2. Send it to the streaming server's signaling endpoint
                // 3. Receive the answer and set it as remote description
                
                // First, create an offer
                createOffer()
                
                // For now, we'll create the offer and let the React Native layer
                // handle the signaling. In a real implementation, you would:
                // - Parse the streaming URL to extract signaling endpoint
                // - Send HTTP POST with the offer to the signaling server
                // - Receive the answer and set it as remote description
                // - Handle ICE candidate exchange
                
                Log.d(TAG, "WebRTC offer creation initiated for stream: $streamUrlOrSignalingInfo")
                
                // Attempt WebRTC signaling with the streaming server
                attemptSignaling(streamUrlOrSignalingInfo)
                
            } catch (e: Exception) {
                Log.e(TAG, "Error starting stream: ${e.message}")
                // Emit error event to React Native
                val params = Arguments.createMap().apply {
                    putString("error", e.message ?: "Unknown error")
                    putString("streamUrl", streamUrlOrSignalingInfo)
                }
                (context as? ThemedReactContext)?.getJSModule(RCTEventEmitter::class.java)?.receiveEvent(id, "onConnectionError", params)
            }
        }
    }

    private fun attemptSignaling(streamUrlOrSignalingInfo: String) {
        Log.d(TAG, "Starting signaling for: $streamUrlOrSignalingInfo")
        
        // Reset connection state flags
        iceGatheringComplete = false
        whepOfferSent = false
        pendingStreamUrl = streamUrlOrSignalingInfo
        
        // Cancel any existing timeout
        iceGatheringTimeoutRunnable?.let { iceGatheringTimeoutHandler?.removeCallbacks(it) }
        
        // Check if this is a direct WHEP URL (like the working web example)
        if (streamUrlOrSignalingInfo.contains("/whep")) {
            Log.d(TAG, "=== DIRECT WHEP URL DETECTED ===")
            pendingStreamUrl = streamUrlOrSignalingInfo
            
            // Create offer and wait for ICE gathering completion
            peerConnection?.createOffer(object : SdpObserver {
                override fun onCreateSuccess(offer: SessionDescription?) {
                    offer?.let {
                        Log.d(TAG, "Local offer created, setting as local description...")
                        peerConnection?.setLocalDescription(object : SdpObserver {
                            override fun onSetSuccess() {
                                Log.d(TAG, "Local description set. Waiting for ICE gathering...")
                                // Emit the local SDP to React Native
                                emitLocalSdp(it)
                                
                                // If ICE gathering is already complete, send immediately
                                if (iceGatheringComplete) {
                                    sendWhepOffer(streamUrlOrSignalingInfo)
                                }
                                // Otherwise wait for onIceGatheringChange callback
                            }
                            override fun onSetFailure(error: String?) {
                                Log.e(TAG, "Failed to set local description: $error")
                                emitConnectionError("Failed to set local description: $error")
                            }
                            override fun onCreateSuccess(p0: SessionDescription?) {}
                            override fun onCreateFailure(p0: String?) {}
                        }, it)
                    }
                }
                override fun onCreateFailure(error: String?) {
                    Log.e(TAG, "Failed to create offer: $error")
                    emitConnectionError("Failed to create offer: $error")
                }
                override fun onSetSuccess() {}
                override fun onSetFailure(p0: String?) {}
            }, MediaConstraints())
            return
        }
        
        // For non-WHEP URLs, try alternative signaling methods
        val streamId = extractStreamId(streamUrlOrSignalingInfo)
        
        // Wait for local SDP offer to be ready
        if (localOffer == null) {
            Log.d(TAG, "Creating local offer first...")
            peerConnection?.createOffer(object : SdpObserver {
                override fun onCreateSuccess(offer: SessionDescription?) {
                    offer?.let {
                        localOffer = it
                        peerConnection?.setLocalDescription(SdpObserverAdapter(), it)
                        emitLocalSdp(it)
                        // Retry signaling with the offer
                        tryAlternativeSignaling(streamUrlOrSignalingInfo, streamId, it)
                    }
                }
                override fun onCreateFailure(error: String?) {
                    Log.e(TAG, "Failed to create offer: $error")
                    emitConnectionError("Failed to create offer: $error")
                }
                override fun onSetSuccess() {}
                override fun onSetFailure(p0: String?) {}
            }, MediaConstraints())
        } else {
            tryAlternativeSignaling(streamUrlOrSignalingInfo, streamId, localOffer!!)
        }
    }
    
    private fun extractStreamId(streamUrl: String): String {
        return try {
            // Extract stream ID from URL like: https://live.spacture.ai:8443/248/holiday-farms-1-park-plaza_9090_cam_02
            val uri = URI(streamUrl)
            val path = uri.path.trimStart('/')
            Log.d(TAG, "Extracted path: $path")
            path // Return the full path as stream ID
        } catch (e: Exception) {
            Log.e(TAG, "Error extracting stream ID: ${e.message}")
            ""
        }
    }
    
    private fun emitConnectionError(message: String) {
        val params = Arguments.createMap().apply {
            putString("error", message)
        }
        (context as? ThemedReactContext)?.getJSModule(RCTEventEmitter::class.java)?.receiveEvent(id, "onConnectionError", params)
    }
    
    private fun emitConnectionStateChange(state: String, streamUrl: String = "") {
        // Thread-safe check to prevent duplicate events
        synchronized(connectionStateLock) {
            if (lastEmittedConnectionState == state) {
                Log.d(TAG, "Skipping duplicate connection state: $state")
                return
            }
        }
        
        // Ensure we're on the main thread for React Native event emission
        Handler(Looper.getMainLooper()).post {
            try {
                // Double-check the state hasn't changed while we were waiting for main thread
                synchronized(connectionStateLock) {
                    if (lastEmittedConnectionState == state) {
                        Log.d(TAG, "State already emitted while waiting for main thread: $state")
                        return@post
                    }
                }
                
                val params = Arguments.createMap().apply {
                    putString("state", state)
                    putString("streamUrl", streamUrl)
                }
                
                // Add comprehensive null checks for context and event emitter
                val themedContext = context as? ThemedReactContext
                if (themedContext != null) {
                    try {
                        val eventEmitter = themedContext.getJSModule(RCTEventEmitter::class.java)
                        if (eventEmitter != null) {
                            eventEmitter.receiveEvent(id, "onConnectionStateChange", params)
                            synchronized(connectionStateLock) {
                                lastEmittedConnectionState = state
                            }
                            Log.d(TAG, "Connection state change event emitted: $state")
                        } else {
                            Log.w(TAG, "EventEmitter is null - cannot emit connection state change")
                        }
                    } catch (e: Exception) {
                        Log.e(TAG, "Error getting JS module for event emission", e)
                    }
                } else {
                    Log.w(TAG, "Cannot emit connection state change - React context is null")
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error emitting connection state change event", e)
            }
        }
    }
    
    private fun tryDirectConnection(streamUrl: String, streamId: String, offer: SessionDescription): Boolean {
        Log.d(TAG, "Attempting direct connection test...")
        
        // For testing: create a dummy answer SDP to see if the connection flow works
        val dummyAnswer = """v=0
o=- 0 0 IN IP4 127.0.0.1
s=-
t=0 0
a=group:BUNDLE 0
a=msid-semantic: WMS
m=video 9 UDP/TLS/RTP/SAVPF 96
c=IN IP4 0.0.0.0
a=rtcp:9 IN IP4 0.0.0.0
a=ice-ufrag:test
a=ice-pwd:testpassword
a=ice-options:trickle
a=fingerprint:sha-256 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00
a=setup:active
a=mid:0
a=sendonly
a=rtcp-mux
a=rtcp-rsize
a=rtpmap:96 H264/90000
a=fmtp:96 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42001f"""
        
        try {
            Log.d(TAG, "Setting dummy answer SDP for testing...")
            val answerSdp = SessionDescription(SessionDescription.Type.ANSWER, dummyAnswer)
            
            peerConnection?.setRemoteDescription(object : SdpObserver {
                override fun onSetSuccess() {
                    Log.d(TAG, "Direct connection test: Remote description set successfully")
                    // This is just a test - in reality we need proper signaling
                }
                override fun onSetFailure(error: String?) {
                    Log.e(TAG, "Direct connection test: Set remote description failed: $error")
                }
                override fun onCreateSuccess(p0: SessionDescription?) {}
                override fun onCreateFailure(p0: String?) {}
            }, answerSdp)
            
            // Return false since this is just a test
            return false
            
        } catch (e: Exception) {
            Log.e(TAG, "Direct connection test failed: ${e.message}")
            return false
        }
    }
    
    private fun tryWebSocketSignaling(streamUrlOrSignalingInfo: String, streamId: String, offer: SessionDescription): Boolean {
        return try {
            Log.d(TAG, "Attempting WebSocket signaling for stream: $streamId")
            
            val baseUrl = extractBaseUrl(streamUrlOrSignalingInfo)
            
            // SpactureAI specific WebSocket endpoints to try
            val wsEndpoints = listOf(
                "$baseUrl/ws",
                "$baseUrl/websocket", 
                "$baseUrl/signaling",
                "$baseUrl/webrtc/ws",
                "$baseUrl/$streamId/ws",
                "$baseUrl/stream/$streamId/ws"
            )
            
            // Try each WebSocket endpoint with real connections
            for (wsUrl in wsEndpoints) {
                Log.d(TAG, "Trying WebSocket endpoint: ${wsUrl.replace("https://", "wss://")}")
                if (tryRealWebSocketConnection(wsUrl.replace("https://", "wss://"), streamId, offer)) {
                    Log.d(TAG, "WebSocket signaling successful!")
                    return true
                }
            }
            
            // If WebSocket fails, try alternative signaling approaches
            Log.d(TAG, "WebSocket signaling failed, trying alternative approaches...")
            return tryAlternativeSignaling(streamUrlOrSignalingInfo, streamId, offer)
            
        } catch (e: Exception) {
            Log.e(TAG, "WebSocket signaling error: ${e.message}")
            false
        }
    }
    
    private fun tryRealWebSocketConnection(wsUrl: String, streamId: String, offer: SessionDescription): Boolean {
        return try {
            Log.d(TAG, "Attempting real WebSocket connection to: $wsUrl")
            
            val client = OkHttpClient.Builder()
                .connectTimeout(5, TimeUnit.SECONDS)
                .readTimeout(10, TimeUnit.SECONDS)
                .writeTimeout(10, TimeUnit.SECONDS)
                .build()
            
            val request = Request.Builder()
                .url(wsUrl)
                .build()
            
            var connectionSuccessful = false
            val latch = CountDownLatch(1)
            
            val webSocket = client.newWebSocket(request, object : WebSocketListener() {
                override fun onOpen(webSocket: WebSocket, response: Response) {
                    Log.d(TAG, "WebSocket connected to: $wsUrl")
                    
                    // Try different SpactureAI signaling message formats
                    val messages = listOf(
                        // Standard WebRTC signaling
                        """{"type":"offer","sdp":"${offer.description}","streamId":"$streamId"}""",
                        
                        // SpactureAI specific formats (guessing based on common patterns)
                        """{"action":"play","streamId":"$streamId","offer":{"type":"offer","sdp":"${offer.description}"}}""",
                        """{"cmd":"start","stream":"$streamId","sdp":{"type":"offer","sdp":"${offer.description}"}}""",
                        """{"method":"play","params":{"streamId":"$streamId","offer":"${offer.description}"}}""",
                        
                        // Simple formats
                        """{"play":"$streamId","offer":"${offer.description}"}""",
                        """{"stream":"$streamId","type":"offer","sdp":"${offer.description}"}"""
                    )
                    
                    // Send the first message format
                    webSocket.send(messages[0])
                    Log.d(TAG, "Sent WebSocket message: ${messages[0].take(100)}...")
                }
                
                override fun onMessage(webSocket: WebSocket, text: String) {
                    Log.d(TAG, "WebSocket message received: $text")
                    
                    try {
                        // Try to parse as JSON and look for answer SDP
                        val jsonResponse = org.json.JSONObject(text)
                        
                        // Check for answer SDP in various formats
                        val answerSdp = when {
                            jsonResponse.has("answer") -> {
                                val answer = jsonResponse.getJSONObject("answer")
                                if (answer.has("sdp")) answer.getString("sdp") else null
                            }
                            jsonResponse.has("sdp") && jsonResponse.getString("type") == "answer" -> {
                                jsonResponse.getString("sdp")
                            }
                            jsonResponse.has("result") -> {
                                val result = jsonResponse.getJSONObject("result")
                                if (result.has("sdp")) result.getString("sdp") else null
                            }
                            else -> null
                        }
                        
                        if (answerSdp != null) {
                            Log.d(TAG, "Received answer SDP: ${answerSdp.take(100)}...")
                            
                            // Set remote description
                            val remoteSdp = SessionDescription(SessionDescription.Type.ANSWER, answerSdp)
                            peerConnection?.setRemoteDescription(object : SdpObserver {
                                override fun onCreateSuccess(p0: SessionDescription?) {}
                                override fun onSetSuccess() {
                                    Log.d(TAG, "Remote description set successfully via WebSocket!")
                                    connectionSuccessful = true
                                    latch.countDown()
                                }
                                override fun onCreateFailure(p0: String?) {
                                    Log.e(TAG, "Create failure: $p0")
                                    latch.countDown()
                                }
                                override fun onSetFailure(p0: String?) {
                                    Log.e(TAG, "Set remote description failed: $p0")
                                    latch.countDown()
                                }
                            }, remoteSdp)
                        } else {
                            Log.d(TAG, "No answer SDP found in response, trying next message format...")
                        }
                        
                    } catch (e: Exception) {
                        Log.e(TAG, "Error parsing WebSocket response: ${e.message}")
                        latch.countDown()
                    }
                }
                
                override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {
                    Log.e(TAG, "WebSocket connection failed: ${t.message}")
                    latch.countDown()
                }
                
                override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {
                    Log.d(TAG, "WebSocket closed: $code - $reason")
                    latch.countDown()
                }
            })
            
            // Wait for connection result
            latch.await(10, TimeUnit.SECONDS)
            webSocket.close(1000, "Done")
            
            connectionSuccessful
            
        } catch (e: Exception) {
            Log.e(TAG, "Real WebSocket connection failed: ${e.message}")
            false
        }
    }

    private fun tryAlternativeSignaling(streamUrl: String, streamId: String, offer: SessionDescription): Boolean {
        Log.d(TAG, "Trying alternative signaling approaches...")
        
        // First, try to discover what SpactureAI actually serves
        if (discoverStreamingProtocol(streamUrl)) {
            return true
        }
        
        // Try WHIP signaling
        Log.d(TAG, "Trying WHIP signaling...")
        if (tryWhipSignaling(streamUrl, offer)) {
            return true
        }
        
        // Try WHEP signaling
        Log.d(TAG, "Trying WHEP signaling...")
        if (tryWhepSignaling(streamUrl, offer)) {
            return true
        }
        
        // Try direct SDP exchange
        Log.d(TAG, "Trying direct SDP exchange...")
        if (tryDirectSdpExchange(streamUrl, streamId, offer)) {
            return true
        }
        
        // Try streaming service specific endpoints
        Log.d(TAG, "Trying streaming service specific endpoints...")
        if (tryStreamingServiceEndpoints(streamUrl, streamId, offer)) {
            return true
        }
        
        // Last resort: Try HLS/DASH protocols
        Log.d(TAG, "Trying HLS/DASH fallback...")
        return tryHlsDashFallback(streamUrl, streamId)
    }
    
    private fun discoverStreamingProtocol(streamUrl: String): Boolean {
        return try {
            Log.d(TAG, "=== DISCOVERING SPACTURE AI STREAMING PROTOCOL ===")
            
            val baseUrl = streamUrl.substringBefore("/248")
            val streamPath = streamUrl.substringAfter(baseUrl)
            
            // Try common streaming manifest endpoints
            val manifestEndpoints = listOf(
                "$streamUrl.m3u8",           // HLS manifest
                "$streamUrl/playlist.m3u8",  // HLS playlist
                "$streamUrl.mpd",            // DASH manifest
                "$streamUrl/manifest.mpd",   // DASH manifest
                "$baseUrl/hls$streamPath.m3u8",     // HLS in hls directory
                "$baseUrl/dash$streamPath.mpd",     // DASH in dash directory
                "$baseUrl/stream$streamPath.m3u8",  // HLS in stream directory
                "$baseUrl/live$streamPath.m3u8"     // HLS in live directory
            )
            
            for (endpoint in manifestEndpoints) {
                Log.d(TAG, "Checking manifest endpoint: $endpoint")
                if (checkEndpointExists(endpoint)) {
                    Log.d(TAG, "Found streaming manifest at: $endpoint")
                    emitConnectionError("SpactureAI uses ${getProtocolType(endpoint)} streaming, not WebRTC. Manifest found at: $endpoint")
                    return true
                }
            }
            
            // Try to discover API endpoints by checking common paths
            val apiEndpoints = listOf(
                "$baseUrl/api/streams",
                "$baseUrl/api/live",
                "$baseUrl/api/channels",
                "$baseUrl/streams",
                "$baseUrl/channels",
                "$baseUrl/live"
            )
            
            for (endpoint in apiEndpoints) {
                Log.d(TAG, "Checking API endpoint: $endpoint")
                val response = checkEndpointWithDetails(endpoint)
                if (response.isNotEmpty() && !response.contains("404")) {
                    Log.d(TAG, "Found API endpoint: $endpoint - Response: ${response.take(200)}")
                    emitConnectionError("Found SpactureAI API at: $endpoint. Response: ${response.take(100)}...")
                    return true
                }
            }
            
            false
        } catch (e: Exception) {
            Log.e(TAG, "Protocol discovery failed: ${e.message}")
            false
        }
    }
    
    private fun getProtocolType(url: String): String {
        return when {
            url.contains(".m3u8") -> "HLS"
            url.contains(".mpd") -> "DASH"
            else -> "Unknown"
        }
    }
    
    private fun checkEndpointExists(endpoint: String): Boolean {
        return try {
            val url = URL(endpoint)
            val connection = url.openConnection() as HttpURLConnection
            connection.requestMethod = "HEAD"
            connection.connectTimeout = 3000
            connection.readTimeout = 3000
            
            val responseCode = connection.responseCode
            Log.d(TAG, "Endpoint $endpoint returned: $responseCode")
            
            responseCode == 200
        } catch (e: Exception) {
            Log.d(TAG, "Endpoint check failed for $endpoint: ${e.message}")
            false
        }
    }
    
    private fun checkEndpointWithDetails(endpoint: String): String {
        return try {
            val url = URL(endpoint)
            val connection = url.openConnection() as HttpURLConnection
            connection.requestMethod = "GET"
            connection.connectTimeout = 3000
            connection.readTimeout = 3000
            
            val responseCode = connection.responseCode
            Log.d(TAG, "API endpoint $endpoint returned: $responseCode")
            
            if (responseCode == 200) {
                val reader = BufferedReader(InputStreamReader(connection.inputStream))
                val response = reader.readText()
                reader.close()
                response
            } else {
                "HTTP $responseCode"
            }
        } catch (e: Exception) {
            Log.d(TAG, "API endpoint check failed for $endpoint: ${e.message}")
            ""
        }
    }
    
    private fun tryHlsDashFallback(streamUrl: String, streamId: String): Boolean {
        Log.d(TAG, "=== TRYING HLS/DASH FALLBACK ===")
        
        // SpactureAI might be serving HLS or DASH instead of WebRTC
        val baseUrl = streamUrl.substringBefore("/248")
        val streamPath = streamUrl.substringAfter(baseUrl)
        
        val streamingUrls = listOf(
            "$streamUrl.m3u8",
            "$streamUrl/index.m3u8",
            "$baseUrl/hls$streamPath.m3u8",
            "$baseUrl/stream$streamPath.m3u8"
        )
        
        for (hlsUrl in streamingUrls) {
            Log.d(TAG, "Trying HLS URL: $hlsUrl")
            if (checkEndpointExists(hlsUrl)) {
                Log.d(TAG, "Found HLS stream at: $hlsUrl")
                emitConnectionError("SpactureAI serves HLS streams, not WebRTC. Use HLS player for: $hlsUrl")
                return true
            }
        }
        
        emitConnectionError("SpactureAI uses proprietary signaling. All standard WebRTC, HLS, and DASH endpoints return 404. Contact SpactureAI for API documentation.")
        return false
    }
    
    private fun tryWhipSignaling(streamUrl: String, offer: SessionDescription): Boolean {
        return try {
            Log.d(TAG, "Trying WHIP signaling...")
            val baseUrl = extractHttpBaseUrl(streamUrl)
            val whipUrl = "$baseUrl/whip"
            
            val url = URL(whipUrl)
            val connection = url.openConnection() as HttpURLConnection
            connection.requestMethod = "POST"
            connection.setRequestProperty("Content-Type", "application/sdp")
            connection.setRequestProperty("Accept", "application/sdp")
            connection.doOutput = true
            connection.connectTimeout = 10000
            connection.readTimeout = 10000
            
            // Send SDP offer
            connection.outputStream.use { os ->
                os.write(offer.description.toByteArray())
            }
            
            val responseCode = connection.responseCode
            Log.d(TAG, "WHIP response code: $responseCode")
            
            if (responseCode == 200 || responseCode == 201) {
                // Read SDP answer
                val answer = connection.inputStream.bufferedReader().use { it.readText() }
                Log.d(TAG, "Received SDP answer via WHIP: ${answer.take(100)}...")
                
                // Set remote description
                val answerSdp = SessionDescription(SessionDescription.Type.ANSWER, answer)
                peerConnection?.setRemoteDescription(object : SdpObserver {
                    override fun onCreateSuccess(p0: SessionDescription?) {}
                    override fun onSetSuccess() {
                        Log.d(TAG, "WHIP signaling successful!")
                    }
                    override fun onCreateFailure(p0: String?) {}
                    override fun onSetFailure(p0: String?) {
                        Log.e(TAG, "Failed to set remote description from WHIP: $p0")
                    }
                }, answerSdp)
                
                return true
            }
            
            false
        } catch (e: Exception) {
            Log.e(TAG, "WHIP signaling failed: ${e.message}")
            false
        }
    }
    
    private fun tryWhepSignaling(streamUrl: String, offer: SessionDescription): Boolean {
        return try {
            Log.d(TAG, "=== ATTEMPTING WHEP SIGNALING ===")
            val baseUrl = extractHttpBaseUrl(streamUrl)
            val streamPath = streamUrl.substringAfter(baseUrl)
            
            // WHEP endpoints to try for receiving streams
            val whepEndpoints = listOf(
                "$baseUrl/whep",                    // Standard WHEP endpoint
                "$baseUrl/whep$streamPath",         // WHEP with stream path
                "$baseUrl/api/whep",                // API WHEP endpoint
                "$baseUrl/api/whep$streamPath",     // API WHEP with stream path
                "$baseUrl/webrtc/whep",             // WebRTC WHEP endpoint
                "$baseUrl/webrtc/whep$streamPath",  // WebRTC WHEP with stream path
                "$baseUrl/play",                    // Simple play endpoint
                "$baseUrl/play$streamPath",         // Play with stream path
                "$baseUrl/receive",                 // Receive endpoint
                "$baseUrl/receive$streamPath"       // Receive with stream path
            )
            
            for (whepUrl in whepEndpoints) {
                Log.d(TAG, "Trying WHEP endpoint: $whepUrl")
                if (attemptWhepExchange(whepUrl, offer)) {
                    Log.d(TAG, "WHEP signaling successful!")
                    return true
                }
            }
            
            false
        } catch (e: Exception) {
            Log.e(TAG, "WHEP signaling error: ${e.message}")
            false
        }
    }
    
    private fun attemptWhepExchange(whepUrl: String, offer: SessionDescription): Boolean {
        return try {
            Log.d(TAG, "Attempting WHEP exchange at: $whepUrl")
            
            val url = URL(whepUrl)
            val connection = url.openConnection() as HttpURLConnection
            connection.requestMethod = "POST"
            connection.setRequestProperty("Content-Type", "application/sdp")
            connection.setRequestProperty("Accept", "application/sdp")
            connection.setRequestProperty("User-Agent", "React-Native-Unified-WebRTC/1.0")
            connection.doOutput = true
            connection.connectTimeout = 10000
            connection.readTimeout = 10000
            
            // Send the SDP offer
            connection.outputStream.use { os ->
                os.write(offer.description.toByteArray())
            }
            
            val responseCode = connection.responseCode
            Log.d(TAG, "WHEP response code: $responseCode for $whepUrl")
            
            if (responseCode == 200 || responseCode == 201) {
                // Read the SDP answer
                val answerSdp = connection.inputStream.bufferedReader().use { it.readText() }
                Log.d(TAG, "WHEP answer SDP received: ${answerSdp.take(100)}...")
                
                // Set remote description with the answer
                val remoteSdp = SessionDescription(SessionDescription.Type.ANSWER, answerSdp)
                peerConnection?.setRemoteDescription(object : SdpObserver {
                    override fun onCreateSuccess(p0: SessionDescription?) {}
                    override fun onSetSuccess() {
                        Log.d(TAG, "WHEP: Remote description set successfully!")
                    }
                    override fun onCreateFailure(p0: String?) {
                        Log.e(TAG, "WHEP: Create failure: $p0")
                    }
                    override fun onSetFailure(p0: String?) {
                        Log.e(TAG, "WHEP: Set remote description failed: $p0")
                        emitConnectionError("WHEP: Failed to set remote description: $p0")
                    }
                }, remoteSdp)
                
                return true
            } else {
                val errorBody = try {
                    connection.errorStream?.bufferedReader()?.use { it.readText() } ?: 
                    connection.inputStream?.bufferedReader()?.use { it.readText() } ?: "No error details"
                } catch (e: Exception) {
                    "Could not read error: ${e.message}"
                }
                Log.e(TAG, "WHEP failed with response code: $responseCode")
                Log.e(TAG, "WHEP error response: $errorBody")
                emitConnectionError("WHEP failed: HTTP $responseCode - $errorBody")
                return false
            }
            
        } catch (e: Exception) {
            Log.e(TAG, "WHEP exchange failed: ${e.message}")
            false
        }
    }

    private fun sendWhepOffer(streamUrl: String) {
        Log.d(TAG, "=== SENDING WHEP OFFER ===")
        val localSdp = peerConnection?.localDescription
        if (localSdp == null) {
            Log.e(TAG, "No local SDP available for WHEP")
            return
        }
        
        Log.d(TAG, "Sending WHEP offer to: $streamUrl")
        Log.d(TAG, "SDP length: ${localSdp.description.length} chars")
        
        executor.execute {
            try {
                val url = URL(streamUrl)
                val connection = url.openConnection() as HttpURLConnection
                connection.requestMethod = "POST"
                connection.setRequestProperty("Content-Type", "application/sdp")
                connection.setRequestProperty("Accept", "application/sdp")
                connection.doOutput = true
                connection.connectTimeout = 10000
                connection.readTimeout = 10000
                
                // Send the SDP offer
                connection.outputStream.use { os ->
                    os.write(localSdp.description.toByteArray())
                }
                
                val responseCode = connection.responseCode
                Log.d(TAG, "WHEP response code: $responseCode")
                
                if (responseCode == 200 || responseCode == 201) {
                    // Read the SDP answer
                    val answerSdp = connection.inputStream.bufferedReader().use { it.readText() }
                    Log.d(TAG, "WHEP answer SDP received: ${answerSdp.take(100)}...")
                    
                    // Set remote description with the answer
                    val remoteSdp = SessionDescription(SessionDescription.Type.ANSWER, answerSdp)
                    peerConnection?.setRemoteDescription(object : SdpObserver {
                        override fun onCreateSuccess(p0: SessionDescription?) {}
                        override fun onSetSuccess() {
                            Log.d(TAG, "WHEP: Remote description set successfully!")
                            Log.d(TAG, "WebRTC connection established via WHEP!")
                            emitConnectionStateChange("connected", streamUrl)
                        }
                        override fun onCreateFailure(p0: String?) {
                            Log.e(TAG, "WHEP: Create failure: $p0")
                        }
                        override fun onSetFailure(p0: String?) {
                            Log.e(TAG, "WHEP: Set remote description failed: $p0")
                            emitConnectionError("WHEP: Failed to set remote description: $p0")
                        }
                    }, remoteSdp)
                } else {
                    val errorBody = try {
                        connection.errorStream?.bufferedReader()?.use { it.readText() } ?: 
                        connection.inputStream?.bufferedReader()?.use { it.readText() } ?: "No error details"
                    } catch (e: Exception) {
                        "Could not read error: ${e.message}"
                    }
                    Log.e(TAG, "WHEP failed with response code: $responseCode")
                    Log.e(TAG, "WHEP error response: $errorBody")
                    emitConnectionError("WHEP failed: HTTP $responseCode - $errorBody")
                }
                
            } catch (e: Exception) {
                Log.e(TAG, "WHEP exchange failed: ${e.message}")
                emitConnectionError("WHEP exchange failed: ${e.message}")
            }
        }
    }
    
    private fun emitLocalSdp(sdp: SessionDescription) {
        val params = Arguments.createMap().apply {
            putString("sdp", sdp.description)
            putString("type", sdp.type.canonicalForm())
        }
        (context as? ThemedReactContext)?.getJSModule(RCTEventEmitter::class.java)?.receiveEvent(id, "onLocalSdpReady", params)
    }
    
    private fun emitIceCandidate(candidate: IceCandidate) {
        val params = Arguments.createMap().apply {
            putString("candidate", candidate.sdp)
            putString("sdpMid", candidate.sdpMid)
            putDouble("sdpMLineIndex", candidate.sdpMLineIndex.toDouble())
        }
        (context as? ThemedReactContext)?.getJSModule(RCTEventEmitter::class.java)?.receiveEvent(id, "onIceCandidateReady", params)
    }

    private fun setupPeerConnection() {
        Log.d(TAG, "Setting up PeerConnection...")
        
        val iceServers = listOf(
            PeerConnection.IceServer.builder("stun:stun.l.google.com:19302").createIceServer(),
        )
        
        val rtcConfig = PeerConnection.RTCConfiguration(iceServers).apply {
            sdpSemantics = PeerConnection.SdpSemantics.UNIFIED_PLAN
            bundlePolicy = PeerConnection.BundlePolicy.MAXBUNDLE
            iceConnectionReceivingTimeout = 5000  // 5 seconds
            iceBackupCandidatePairPingInterval = 2000  // 2 seconds
            iceCheckMinInterval = 50  // 50ms minimum check interval
        }
        
        peerConnection = peerConnectionFactory?.createPeerConnection(rtcConfig, object : PeerConnection.Observer {
            override fun onSignalingChange(newState: PeerConnection.SignalingState?) {}
            override fun onIceConnectionChange(newState: PeerConnection.IceConnectionState?) {
                Log.d(TAG, "ICE connection state changed: $newState")
                when (newState) {
                    PeerConnection.IceConnectionState.CONNECTED -> {
                        // Only emit if we haven't already emitted connected state
                        if (lastEmittedConnectionState != "connected") {
                            emitConnectionStateChange("connected")
                        }
                    }
                    PeerConnection.IceConnectionState.DISCONNECTED -> {
                        emitConnectionStateChange("disconnected")
                    }
                    PeerConnection.IceConnectionState.FAILED -> {
                        emitConnectionStateChange("failed")
                    }
                    else -> {}
                }
            }
            override fun onIceConnectionReceivingChange(receiving: Boolean) {}
            override fun onIceGatheringChange(newState: PeerConnection.IceGatheringState?) {
                Log.d(TAG, "ICE gathering state: $newState")
                when (newState) {
                    PeerConnection.IceGatheringState.GATHERING -> {
                        // Start timeout timer for ICE gathering (max 10 seconds)
                        iceGatheringTimeoutHandler = Handler(Looper.getMainLooper())
                        iceGatheringTimeoutRunnable = Runnable {
                            if (!iceGatheringComplete && !whepOfferSent) {
                                Log.w(TAG, "ICE gathering timeout reached, proceeding with available candidates")
                                iceGatheringComplete = true
                                whepOfferSent = true
                                pendingStreamUrl?.let { url ->
                                    if (url.contains("/whep")) {
                                        sendWhepOffer(url)
                                    }
                                }
                            }
                        }
                        iceGatheringTimeoutHandler?.postDelayed(iceGatheringTimeoutRunnable!!, 10000) // 10 second timeout
                    }
                    PeerConnection.IceGatheringState.COMPLETE -> {
                        // Cancel timeout since gathering completed normally
                        iceGatheringTimeoutRunnable?.let { iceGatheringTimeoutHandler?.removeCallbacks(it) }
                        
                        // ICE gathering complete - ready to send offer for WHEP
                        iceGatheringComplete = true
                        if (!whepOfferSent) {
                            whepOfferSent = true
                            pendingStreamUrl?.let { url ->
                                if (url.contains("/whep")) {
                                    // This is a direct WHEP URL, send offer now
                                    sendWhepOffer(url)
                                }
                            }
                        } else {
                            Log.d(TAG, "WHEP offer already sent, skipping duplicate")
                        }
                    }
                    else -> {}
                }
            }
            
            override fun onIceCandidate(candidate: IceCandidate?) {
                candidate?.let {
                    Log.d(TAG, "ICE candidate: ${it.sdp}")
                    emitIceCandidate(it)
                }
            }
            
            override fun onAddTrack(receiver: RtpReceiver?, mediaStreams: Array<out MediaStream>?) {
                mediaStreams?.forEach { stream ->
                    Log.d(TAG, "Remote stream added: ${stream.id}")
                    stream.videoTracks?.forEach { videoTrack ->
                        val trackId = "${stream.id}_${videoTrack.id()}"
                        Log.d(TAG, "Scheduling video track addition: $trackId")
                        
                        // Check codec information if available
                        try {
                            receiver?.track()?.let { track ->
                                if (track is VideoTrack) {
                                    // Log video track details for debugging
                                    Log.d(TAG, "Video track details - ID: ${track.id()}, State: ${track.state()}")
                                }
                            }
                        } catch (e: Exception) {
                            Log.w(TAG, "Could not get codec info for track $trackId: ${e.message}")
                        }
                        
                        Handler(Looper.getMainLooper()).post {
                            try {
                                synchronized(videoTrackLock) {
                                    if (!addedVideoTracks.contains(trackId)) {
                                        surfaceViewRenderer?.let { renderer ->
                                            // Add extra safety checks for H.265 streams
                                            Log.d(TAG, "Attempting to add video track to renderer: $trackId")
                                            
                                            // Add a small delay to ensure renderer is ready
                                            Handler(Looper.getMainLooper()).postDelayed({
                                                try {
                                                    synchronized(videoTrackLock) {
                                                        // Double-check track hasn't been added in the meantime
                                                        if (!addedVideoTracks.contains(trackId)) {
                                                            // Try to add the video track with timeout protection
                                                            val addTrackSuccess = try {
                                                                Log.d(TAG, "Adding video track to renderer: $trackId")
                                                                videoTrack.addSink(renderer)
                                                                addedVideoTracks.add(trackId)
                                                                Log.d(TAG, "Video track successfully added: $trackId")
                                                                true
                                                            } catch (e: Exception) {
                                                                Log.e(TAG, "Failed to add video track to renderer: $trackId", e)
                                                                false
                                                            }
                                                            
                                                            if (!addTrackSuccess) {
                                                                Log.e(TAG, "Failed to add video track: $trackId")
                                                            }
                                                        } else {
                                                            Log.d(TAG, "Video track already added during delay: $trackId")
                                                        }
                                                    }
                                                } catch (e: Exception) {
                                                    Log.e(TAG, "Error in delayed video track addition: $trackId", e)
                                                }
                                            }, 100) // 100ms delay to ensure renderer stability
                                        } ?: run {
                                            Log.e(TAG, "SurfaceViewRenderer is null, cannot add track: $trackId")
                                        }
                                    } else {
                                        Log.d(TAG, "Video track already added, skipping: $trackId")
                                    }
                                }
                            } catch (e: Exception) {
                                Log.e(TAG, "Critical error in video track handling: $trackId", e)
                                // Log error instead of emitting to prevent further crashes
                                Log.e(TAG, "Video track processing failed for $trackId: ${e.message}")
                            }
                        }
                    }
                }
            }
            
            override fun onAddStream(stream: MediaStream?) {
                Log.d(TAG, "onAddStream called: ${stream?.id} - DISABLED for crash testing")
                // Temporarily disabled to test if having both callbacks causes issues
                // Even with deduplication, having both callbacks might cause problems
                /*
                stream?.videoTracks?.forEach { videoTrack ->
                    val trackId = "${stream.id}_${videoTrack.id()}"
                    Log.d(TAG, "Scheduling video track addition from stream: $trackId")
                    Handler(Looper.getMainLooper()).post {
                        try {
                            synchronized(videoTrackLock) {
                                if (!addedVideoTracks.contains(trackId)) {
                                    surfaceViewRenderer?.let { renderer ->
                                        videoTrack.addSink(renderer)
                                        addedVideoTracks.add(trackId)
                                        Log.d(TAG, "Video track from stream added to renderer: $trackId")
                                    }
                                } else {
                                    Log.d(TAG, "Video track from stream already added, skipping: $trackId")
                                }
                            }
                        } catch (e: Exception) {
                            Log.e(TAG, "Error adding video track from stream to renderer: $trackId", e)
                        }
                    }
                }
                */
            }
            
            override fun onRemoveStream(stream: MediaStream?) {
                Log.d(TAG, "Stream removed")
            }
            
            override fun onDataChannel(dataChannel: DataChannel?) {}
            override fun onRenegotiationNeeded() {}
            override fun onIceCandidatesRemoved(candidates: Array<out IceCandidate>?) {}
            override fun onTrack(transceiver: RtpTransceiver?) {}
            override fun onConnectionChange(newState: PeerConnection.PeerConnectionState?) {
                Log.d(TAG, "Peer connection state changed: $newState")
                when (newState) {
                    PeerConnection.PeerConnectionState.CONNECTED -> {
                        // Only emit if we haven't already emitted connected state
                        if (lastEmittedConnectionState != "connected") {
                            emitConnectionStateChange("connected")
                        }
                    }
                    PeerConnection.PeerConnectionState.DISCONNECTED -> {
                        emitConnectionStateChange("disconnected")
                    }
                    PeerConnection.PeerConnectionState.FAILED -> {
                        emitConnectionStateChange("failed")
                    }
                    PeerConnection.PeerConnectionState.CLOSED -> {
                        emitConnectionStateChange("closed")
                    }
                    else -> {}
                }
            }
        })
        
        // Add receive-only video transceiver (matching web example)
        peerConnection?.addTransceiver(
            MediaStreamTrack.MediaType.MEDIA_TYPE_VIDEO,
            RtpTransceiver.RtpTransceiverInit(RtpTransceiver.RtpTransceiverDirection.RECV_ONLY)
        )
        
        Log.d(TAG, "PeerConnection setup complete")
    }

    fun disconnect() {
        try {
            Log.d(TAG, "Disconnecting WebRTC connection")
            
            // Clear tracked video tracks
            synchronized(videoTrackLock) {
                addedVideoTracks.clear()
            }
            
            peerConnection?.close()
            peerConnection = null
            
            // Clear renderer
            surfaceViewRenderer?.let { renderer ->
                Handler(Looper.getMainLooper()).post {
                    try {
                        renderer.clearImage()
                        renderer.release()
                    } catch (e: Exception) {
                        Log.e(TAG, "Error releasing renderer", e)
                    }
                }
            }
            
            emitConnectionStateChange("disconnected")
        } catch (e: Exception) {
            Log.e(TAG, "Error during disconnect", e)
        }
    }

    fun dispose() {
        Log.d(TAG, "Disposing WebRTC resources")
        
        executor.execute {
            try {
                remoteVideoTrack?.removeSink(surfaceViewRenderer)
                localVideoTrack?.removeSink(surfaceViewRenderer)
                remoteVideoTrack?.dispose()
                localVideoTrack?.dispose()
                
                post {
                    surfaceViewRenderer?.release()
                    surfaceViewRenderer = null
                }
                
                peerConnection?.dispose()
                peerConnection = null
                
                Log.d(TAG, "WebRTC resources disposed")
            } catch (e: Exception) {
                Log.e(TAG, "Error disposing resources: ${e.message}")
            }
        }
    }

    // SdpObserver implementation
    open class SdpObserverAdapter : SdpObserver {
        override fun onCreateSuccess(sdp: SessionDescription?) {}
        override fun onSetSuccess() {}
        override fun onCreateFailure(error: String?) {}
        override fun onSetFailure(error: String?) {}
    }
    
    private fun extractBaseUrl(streamUrl: String): String {
        return try {
            val uri = URI(streamUrl)
            val scheme = if (uri.scheme == "https") "wss" else "ws"
            "$scheme://${uri.host}:${uri.port}"
        } catch (e: Exception) {
            Log.e(TAG, "Error extracting base URL: ${e.message}")
            "wss://live.spacture.ai:8443"
        }
    }
    
    private fun extractHttpBaseUrl(streamUrl: String): String {
        return try {
            val uri = URI(streamUrl)
            "${uri.scheme}://${uri.host}:${uri.port}"
        } catch (e: Exception) {
            Log.e(TAG, "Error extracting HTTP base URL: ${e.message}")
            "https://live.spacture.ai:8443"
        }
    }
    
    private fun tryDirectSdpExchange(streamUrl: String, streamId: String, offer: SessionDescription): Boolean {
        return try {
            Log.d(TAG, "Trying direct SDP exchange...")
            val baseUrl = extractHttpBaseUrl(streamUrl)
            
            // Try common SDP exchange endpoints
            val endpoints = listOf(
                "$baseUrl/api/webrtc/offer",
                "$baseUrl/webrtc/offer", 
                "$baseUrl/offer",
                "$baseUrl/$streamId/offer",
                "$baseUrl/stream/$streamId/offer"
            )
            
            for (endpoint in endpoints) {
                if (attemptSdpExchange(endpoint, offer)) {
                    return true
                }
            }
            
            false
        } catch (e: Exception) {
            Log.d(TAG, "Direct SDP exchange failed: ${e.message}")
            false
        }
    }
    
    private fun tryStreamingServiceEndpoints(streamUrl: String, streamId: String, offer: SessionDescription): Boolean {
        return try {
            Log.d(TAG, "Trying streaming service specific endpoints...")
            
            // Try endpoints specific to this streaming service
            val endpoints = listOf(
                "https://live.spacture.ai:8443/api/webrtc/play",
                "https://live.spacture.ai:8443/webrtc/play",
                "https://live.spacture.ai:8443/play/$streamId",
                "https://live.spacture.ai:8443/stream/play"
            )
            
            for (endpoint in endpoints) {
                if (attemptStreamingServiceCall(endpoint, streamId, offer)) {
                    return true
                }
            }
            
            false
        } catch (e: Exception) {
            Log.d(TAG, "Streaming service endpoints failed: ${e.message}")
            false
        }
    }
    
    private fun attemptSdpExchange(endpoint: String, offer: SessionDescription): Boolean {
        return try {
            Log.d(TAG, "Attempting SDP exchange at: $endpoint")
            
            val url = URL(endpoint)
            val connection = url.openConnection() as HttpURLConnection
            connection.requestMethod = "POST"
            connection.setRequestProperty("Content-Type", "application/json")
            connection.setRequestProperty("Accept", "application/json")
            connection.doOutput = true
            connection.connectTimeout = 5000
            connection.readTimeout = 5000
            
            val requestBody = JSONObject().apply {
                put("type", "offer")
                put("sdp", offer.description)
            }
            
            connection.outputStream.use { os ->
                os.write(requestBody.toString().toByteArray())
            }
            
            val responseCode = connection.responseCode
            Log.d(TAG, "SDP exchange response code: $responseCode for $endpoint")
            
            if (responseCode == 200) {
                val response = connection.inputStream.bufferedReader().use { it.readText() }
                Log.d(TAG, "SDP exchange response: ${response.take(200)}...")
                
                val jsonResponse = JSONObject(response)
                if (jsonResponse.has("sdp")) {
                    val answerSdp = SessionDescription(SessionDescription.Type.ANSWER, jsonResponse.getString("sdp"))
                    peerConnection?.setRemoteDescription(object : SdpObserver {
                        override fun onCreateSuccess(p0: SessionDescription?) {}
                        override fun onSetSuccess() {
                            Log.d(TAG, "SDP exchange successful!")
                        }
                        override fun onCreateFailure(p0: String?) {}
                        override fun onSetFailure(p0: String?) {
                            Log.e(TAG, "Failed to set remote description: $p0")
                        }
                    }, answerSdp)
                    return true
                }
            }
            
            false
        } catch (e: Exception) {
            Log.d(TAG, "SDP exchange failed for $endpoint: ${e.message}")
            false
        }
    }
    
    private fun attemptStreamingServiceCall(endpoint: String, streamId: String, offer: SessionDescription): Boolean {
        return try {
            Log.d(TAG, "Attempting streaming service call: $endpoint")
            
            val url = URL(endpoint)
            val connection = url.openConnection() as HttpURLConnection
            connection.requestMethod = "POST"
            connection.setRequestProperty("Content-Type", "application/json")
            connection.setRequestProperty("Accept", "application/json")
            connection.doOutput = true
            connection.connectTimeout = 10000
            connection.readTimeout = 10000
            
            val requestBody = JSONObject().apply {
                put("streamId", streamId)
                put("offer", JSONObject().apply {
                    put("type", "offer")
                    put("sdp", offer.description)
                })
            }
            
            connection.outputStream.use { os ->
                os.write(requestBody.toString().toByteArray())
            }
            
            val responseCode = connection.responseCode
            Log.d(TAG, "Streaming service response code: $responseCode for $endpoint")
            
            if (responseCode == 200) {
                val response = connection.inputStream.bufferedReader().use { it.readText() }
                Log.d(TAG, "Streaming service response: ${response.take(200)}...")
                
                val jsonResponse = JSONObject(response)
                if (jsonResponse.has("answer")) {
                    val answerObj = jsonResponse.getJSONObject("answer")
                    val answerSdp = SessionDescription(SessionDescription.Type.ANSWER, answerObj.getString("sdp"))
                    peerConnection?.setRemoteDescription(object : SdpObserver {
                        override fun onCreateSuccess(p0: SessionDescription?) {}
                        override fun onSetSuccess() {
                            Log.d(TAG, "Streaming service signaling successful!")
                        }
                        override fun onCreateFailure(p0: String?) {}
                        override fun onSetFailure(p0: String?) {
                            Log.e(TAG, "Failed to set remote description: $p0")
                        }
                    }, answerSdp)
                    return true
                }
            }
            
            false
        } catch (e: Exception) {
            Log.d(TAG, "Streaming service call failed for $endpoint: ${e.message}")
            false
        }
    }
}
